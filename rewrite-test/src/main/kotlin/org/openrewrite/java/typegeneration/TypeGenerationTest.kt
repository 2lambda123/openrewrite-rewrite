/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.typegeneration

import org.assertj.core.api.Assertions.assertThat
import org.intellij.lang.annotations.Language
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Test
import org.objectweb.asm.*
import org.objectweb.asm.util.ASMifier
import org.objectweb.asm.util.TraceClassVisitor
import org.openrewrite.InMemoryExecutionContext
import org.openrewrite.Parser
import org.openrewrite.java.JavaParser
import org.openrewrite.java.tree.J
import java.io.ByteArrayOutputStream
import java.io.PrintStream
import java.io.PrintWriter
import java.nio.file.Path
import java.nio.file.Paths

interface TypeGenerationTest {

    // This test provides a generic way to assert that a java source (as a string or as a path) can first be
    // compiled using the runtime classpath and then it will extract the types from the resulting AST and attempt
    // to compile the source again using just the generated byte code.
    //
    // The two variants of assertCompilationWithByteCode only require a source, but allows for the parser, and two
    // method callbacks to be overridden to assert test conditions.
    //
    // The system.out is captured and passed to the compiler out handler (and the default is to swallow that output)
    // checkCompilationUnit can be use used to verify type attribution on the compilation unit after the second parse.

    val debugAsm: Boolean
        get() = true

    val rewriteRoot: Path
        get () {
            return Paths.get(TypeGenerationTest::class.java.getResource("./")!!.toURI())
                .resolve("../../../../../../../../").normalize()
        }

    val parser: JavaParser
        get() = JavaParser.fromJavaVersion()
            .logCompilationWarningsAndErrors(true)
            .build()

    //Default is to swallow compiler output, this can be overridden for any given test.
    val defaultCompilerOutputHandler: (String) -> Unit
        get() = {}

    @Test
    fun testCompilationUsingExtractedTypes() =
        assertCompilationWithByteCode(
            source = """
                    package org.example;
                    
                    import org.openrewrite.internal.StringUtils;
                    import java.util.SortedMap;
                    import java.util.TreeMap;
                    
                    public class Example {
                        public void foo() {
                            SortedMap<Integer, Long> sortedMap = new TreeMap<>();
                            sortedMap.put(1, 2L);
                            StringUtils.mostCommonIndent(sortedMap);
                        }
                    }
            """.trimIndent(),
            checkCompilerOutput = System.out::println,
            checkCompilationUnit = { compilationUnit ->
                //Make sure the method invocation to "mostCommonIndent" has a type:
                val method = compilationUnit.classes[0].body.statements[0] as J.MethodDeclaration
                val methodInvocation = method.body?.statements?.get(2) as J.MethodInvocation
                assertThat(methodInvocation.type).isNotNull
            }
        )

    @Test
    fun testMethodTypeParameters() =
        assertCompilationWithByteCode(
            parser = JavaParser.fromJavaVersion()
                .classpath("")
                .dependsOn(listOf(
                    Parser.Input.fromString("""
                        package org.openrewrite.style;
                        
                        public class Style {}
                        public class NamedStyles {}
                        public class ObjectIdGenerator<T> {}
                        """),

                    Parser.Input.fromString("""
                        package org.openrewrite.style;
                        
                        public class MethodParameters {
                             public static <S extends Style> S merge(Class<S> styleClass, Iterable<? extends NamedStyles> namedStyles) {return null}
                             public static Class<? extends ObjectIdGenerator<?>> generator() {return null}
                        }
                        """)),
                )
                .build(),
            source = """
                    package org.example;
                    
                    import org.openrewrite.style.MethodParameters;
                    import org.openrewrite.style.Style;
                    import java.util.ArrayList;
                    
                    public class Example {
                        <S extends Style> S getStyle(Class<S> style) {
                            MethodParameters.generator();
                            return MethodParameters.merge(style, new ArrayList<>());
                        }
                    }
            """.trimIndent(),
            checkCompilerOutput = System.out::println,
            checkCompilationUnit = { compilationUnit ->
                //Make sure the method invocation to "mostCommonIndent" has a type:
                compilationUnit.classes[0].body.statements[0] as J.MethodDeclaration
            }
        )

    //Need to handle generics better before we can enable this test.
    @Test
    @Disabled
    fun testFunctionalInterfaceWithLambdas() =
        assertCompilationWithByteCode(
            parser = JavaParser.fromJavaVersion()
                .classpath("")
                .dependsOn(listOf(
                    Parser.Input.fromString("""
                        package org.example.interfaces;
                        import java.util.*;
                        
                        public interface NoGenericsNoReturn {
                            public void yodel(String lay, long he, Integer hoo);  
                        }
                        public interface NoGenerics {
                            public Date yodel(String lay, long he, Integer hoo);  
                        }

                        public interface Generics<T, R> {
                            public R yodel(T lay, List<String> he, Set<Integer> hoo);  
                        }
                        
                        public interface YodelUtils {
                            public void yodelSome(NoGenericsNoReturn song);
                            public void yodelMore(NoGenerics song);
                            public void tooMuchYodelling(Generics<String, String>  song);
                        }
                        """))
                ).build(),
            source = """
                    package org.example;
                    
                    import org.example.interfaces.*;
                    import java.util.*;
                    
                    public class Example {
                        YodelUtils yodellingUtils;
                        public void yodeller() {
                            yodellingUtils.yodelSome((l, h, hoo) -> {});
                            yodellingUtils.yodelMore((l, h, hoo) -> new Date());
                            yodellingUtils.tooMuchYodelling((l, h, hoo) -> "hello");
                        }
                    }
            """.trimIndent(),
            checkCompilerOutput = System.out::println,
            checkCompilationUnit = { compilationUnit ->

                val method = compilationUnit.classes[0].body.statements[1] as J.MethodDeclaration

                val yodelSome = method.body!!.statements[0] as J.MethodInvocation
                val yodelMore = method.body!!.statements[1] as J.MethodInvocation
                val tooMuchYodelling = method.body!!.statements[2] as J.MethodInvocation
                assertThat((yodelSome.arguments[0] as J.Lambda).type).isNotNull
                assertThat((yodelMore.arguments[0] as J.Lambda).type).isNotNull
                assertThat((tooMuchYodelling.arguments[0] as J.Lambda).type).isNotNull
            }
        )

    //Because the structure of these source files can (and likely will) change, these should only be run manually.
    @Test
    @Disabled
    fun testGenericTypeAttribution() {
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/Tree.java"),
            checkCompilerOutput = System.out::println
        )
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/internal/RecipeIntrospectionUtils.java"),
            checkCompilerOutput = System.out::println
        )
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/marker/Marker.java"),
            checkCompilerOutput = System.out::println
        )
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/marker/Markers.java"),
            checkCompilerOutput = System.out::println
        )
    }

    //Because the structure of these source files can (and likely will) change, these should only be run manually.
    @Test
    @Disabled
    fun testInvalidByteCode() = assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/config/ClasspathScanningLoader.java"),
            checkCompilerOutput = System.out::println
        )

    //Because the structure of these source files can (and likely will) change, these should only be run manually.
    @Test
    @Disabled
    fun testAnnotationTypeAttribution() = assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/style/Style.java"),
            checkCompilerOutput = System.out::println
        )

    @Test
    @Disabled
    fun testRegressions() {
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/ExecutionContext.java"),
            checkCompilerOutput = System.out::println
        )
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/SourceFile.java"),
            checkCompilerOutput = System.out::println
        )
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/internal/lang/NullUtils.java"),
            checkCompilerOutput = System.out::println
        )
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/internal/MetricsHelper.java"),
            checkCompilerOutput = System.out::println
        )
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/internal/ListUtils.java"),
            checkCompilerOutput = System.out::println
        )
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/internal/StringUtils.java"),
            checkCompilerOutput = System.out::println
        )
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/internal/PropertyPlaceholderHelper.java"),
            checkCompilerOutput = System.out::println
        )
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/TreePrinter.java"),
            checkCompilerOutput = System.out::println
        )
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/Option.java"),
            checkCompilerOutput = System.out::println
        )
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/Validated.java"),
            checkCompilerOutput = System.out::println
        )
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/config/ResourceLoader.java"),
            checkCompilerOutput = System.out::println
        )
        assertCompilationWithByteCode(
            path = rewriteRoot.resolve("rewrite-core/src/main/java/org/openrewrite/config/RecipeIntrospectionException.java"),
            checkCompilerOutput = System.out::println
        )
    }

    /**
     * This method will use load the source file represented by the path and then parse that file with the parser. It
     * will then extract the types out of the generates AST and then recompile the source with a new parser (that does
     * not have the classpath of the original parser) that is seeded with just the types extracted from the AST. The
     * compilation unit from the second parse is then passed into the afterConditions method and that method can be
     * used to verify type attribution was successful.
     */
    fun assertCompilationWithByteCode(
        path: Path,
        parser: JavaParser = this.parser,
        checkCompilationUnit: (J.CompilationUnit) -> Unit = {},
        checkCompilerOutput: (String) -> Unit = this.defaultCompilerOutputHandler,
    ) {
        val inputs = listOf(path)
        val standardOut = System.out
        val outputStreamCaptor = ByteArrayOutputStream()

        PrintStream(outputStreamCaptor).use {
            try {
                System.setOut(PrintStream(outputStreamCaptor))
                println("------------------- Initial Compilation (${path}) --------------------------------------")
                var compilationUnit = parser.parse(inputs, null, InMemoryExecutionContext())[0]
                val typeInformation = TypeInformation(if (debugAsm) System.out else null)
                TypeExtractionVisitor().visit(compilationUnit, typeInformation)
                val dynamicClasses = typeInformation.typesAsByteCode

                println("------------------- Byte Code Only Compilation (${path}) -------------------------------")
                compilationUnit = JavaParser.fromJavaVersion()
                    .logCompilationWarningsAndErrors(true)
                    .classpath("")
                    .classpath(*dynamicClasses.toTypedArray())
                    .build()
                    .parse(inputs, null, InMemoryExecutionContext())[0]

                System.setOut(standardOut)
                checkCompilerOutput(outputStreamCaptor.toString())
                checkCompilationUnit(compilationUnit)
            } finally {
                System.setOut(standardOut)
            }

        }
    }

    /**
     * This method will parse the source string using the parser that is passed in. It will then extract the types out
     * of the generated AST and then recompile the source with a new parser (that does not have the classpath of the
     * original parser) that is seeded with just the types extracted from the original AST.The
     * compilation unit from the second parse is then passed into the afterConditions method and that method can be
     * used to verify type attribution was successful.
     */
    fun assertCompilationWithByteCode(
        @Language("java") source: String,
        parser: JavaParser = this.parser,
        checkCompilationUnit: (J.CompilationUnit) -> Unit = {},
        checkCompilerOutput: (String) -> Unit = this.defaultCompilerOutputHandler,
    ) {

        val standardOut = System.out
        val outputStreamCaptor = ByteArrayOutputStream()

        PrintStream(outputStreamCaptor).use {
            try {
                System.setOut(PrintStream(outputStreamCaptor))
                println("------------------- Initial Compilation --------------------------------------")

                var compilationUnit = parser.parse(source)[0]
                val typeInformation = TypeInformation(if (debugAsm) System.out else null)
                TypeExtractionVisitor().visit(compilationUnit, typeInformation)
                val dynamicClasses = typeInformation.typesAsByteCode

                println("------------------- Byte Code Only Compilation -------------------------------")
                compilationUnit = JavaParser.fromJavaVersion()
                    .logCompilationWarningsAndErrors(true)
                    .classpath("")
                    .classpath(*dynamicClasses.toTypedArray())
                    .build()
                    .parse(source)[0]

                System.setOut(standardOut)
                checkCompilerOutput(outputStreamCaptor.toString())
                checkCompilationUnit(compilationUnit)
            } finally {
                System.setOut(standardOut)
            }
        }
    }

    //This is used to print the representation of a class using ASM's utilities.
    @Test
    @Disabled
    fun print() {
        printClass("com.fasterxml.jackson.annotation.ObjectIdGenerator")
        //printClass("org.openrewrite.TreeVisitor")
        //printClass("com.fasterxml.jackson.annotation.JsonIdentityInfo")
        //printClass("org.openrewrite.marker.Markers")
        //printClass("java.util.List")
        //printClass("io.github.classgraph.ResourceList")
        //printClass("io.github.classgraph.ResourceList.InputStreamConsumer")
        //printClass("org.openrewrite.style.NamedStyles")
        //printClass("com.fasterxml.jackson.annotation.JsonProperty")
        //printClass("org.openrewrite.internal.StringUtils")

        //printClass("com.fasterxml.jackson.annotation.JsonTypeInfo.Id")
    }
    fun printClass(className : String) {
        val names = className.split(".")

        var cName = ""
        for(name in names.reversed()) {
            cName = if (cName.isNotEmpty() && name[0].isUpperCase()) {
                "$name\$$cName"
            } else if (cName.isNotEmpty()) {
                "$name.$cName"
            } else {
                name
            }
        }

        val writer = PrintWriter(System.out)
        val reader = ClassReader(cName)

        val classWriter = skippingVisitor(TraceClassVisitor(ClassWriter(0), writer))
        println("Generated Types: ")
        reader.accept(classWriter, 0)
        writer.flush()

        println("ASMIFER: ")
        printAsm(cName)
    }

    fun printAsm(className : String) {
        ASMifier.main(arrayOf(className))
    }
    fun skippingVisitor(visitor : ClassVisitor) : ClassVisitor {
        return object : ClassVisitor(Opcodes.ASM9, visitor) {
            override fun visitAnnotation(descriptor: String?, visible: Boolean): AnnotationVisitor? {
                return null
            }

            override fun visitField(
                access: Int,
                name: String?,
                descriptor: String?,
                signature: String?,
                value: Any?,
            ): FieldVisitor {
                return object: FieldVisitor(Opcodes.ASM9, super.visitField(access, name, descriptor, signature, value)) {
                    override fun visitTypeAnnotation(
                        typeRef: Int,
                        typePath: TypePath?,
                        descriptor: String?,
                        visible: Boolean,
                    ): AnnotationVisitor? {
                        return null
                    }

                    override fun visitAnnotation(descriptor: String?, visible: Boolean): AnnotationVisitor? {
                        return null
                    }
                }
            }
        }
    }
}